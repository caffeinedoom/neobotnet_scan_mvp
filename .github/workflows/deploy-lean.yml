# ================================================================
# LEAN DEPLOYMENT WORKFLOW
# ================================================================
# Simplified workflow for NeoBot-Net LEAN MVP
# - Backend API on ECS (minimal, for auth + public data API)
# - Scan containers: Subfinder, DNSx, HTTPx, Katana
# - Frontend: Deployed separately via Vercel
# ================================================================

name: Deploy LEAN (Development)

on:
  push:
    branches: [dev, main]
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Force rebuild all containers?'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: neobotnet-v2-dev-cluster
  
  # ECR Repositories
  ECR_BACKEND: neobotnet-backend
  ECR_ORCHESTRATOR: neobotnet-v2-dev-orchestrator
  ECR_SUBFINDER: neobotnet-v2-dev-subfinder
  ECR_DNSX: neobotnet-v2-dev-dnsx
  ECR_HTTPX: neobotnet-v2-dev-httpx
  ECR_KATANA: neobotnet-v2-dev-katana
  ECR_TYVT: neobotnet-v2-dev-tyvt

jobs:
  # ================================================================
  # Job 1: Change Detection
  # ================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      orchestrator: ${{ steps.changes.outputs.orchestrator }}
      subfinder: ${{ steps.changes.outputs.subfinder }}
      dnsx: ${{ steps.changes.outputs.dnsx }}
      httpx: ${{ steps.changes.outputs.httpx }}
      katana: ${{ steps.changes.outputs.katana }}
      tyvt: ${{ steps.changes.outputs.tyvt }}
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
      skip: ${{ steps.changes.outputs.skip }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 2
        
    - name: Analyze Changes
      id: changes
      run: |
        echo "üîç Analyzing changes..."
        
        CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
        
        # Force all if requested or first commit
        if [ "${{ github.event.inputs.force_all }}" = "true" ] || [ -z "$CHANGED" ]; then
          echo "backend=true" >> $GITHUB_OUTPUT
          echo "orchestrator=true" >> $GITHUB_OUTPUT
          echo "subfinder=true" >> $GITHUB_OUTPUT
          echo "dnsx=true" >> $GITHUB_OUTPUT
          echo "httpx=true" >> $GITHUB_OUTPUT
          echo "katana=true" >> $GITHUB_OUTPUT
          echo "tyvt=true" >> $GITHUB_OUTPUT
          echo "infrastructure=true" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Detect specific changes
        BACKEND=$(echo "$CHANGED" | grep -q "^backend/app\|^backend/requirements\|^backend/Dockerfile" && echo true || echo false)
        # Orchestrator rebuilds when CLI orchestrator changes OR when backend changes (since it depends on backend)
        ORCHESTRATOR=$(echo "$CHANGED" | grep -q "^cli/orchestrator\|^backend/app" && echo true || echo false)
        SUBFINDER=$(echo "$CHANGED" | grep -q "^backend/containers/subfinder-go" && echo true || echo false)
        DNSX=$(echo "$CHANGED" | grep -q "^backend/containers/dnsx-go" && echo true || echo false)
        HTTPX=$(echo "$CHANGED" | grep -q "^backend/containers/httpx-go" && echo true || echo false)
        KATANA=$(echo "$CHANGED" | grep -q "^backend/containers/katana-go" && echo true || echo false)
        TYVT=$(echo "$CHANGED" | grep -q "^backend/containers/tyvt-go" && echo true || echo false)
        INFRA=$(echo "$CHANGED" | grep -q "^infrastructure\|^.github/workflows" && echo true || echo false)
        
        # Check if only docs changed
        SKIP=true
        for f in $CHANGED; do
          case "$f" in
            *.md|docs/*) ;;
            *) SKIP=false ;;
          esac
        done
        
        echo "backend=$BACKEND" >> $GITHUB_OUTPUT
        echo "orchestrator=$ORCHESTRATOR" >> $GITHUB_OUTPUT
        echo "subfinder=$SUBFINDER" >> $GITHUB_OUTPUT
        echo "dnsx=$DNSX" >> $GITHUB_OUTPUT
        echo "httpx=$HTTPX" >> $GITHUB_OUTPUT
        echo "katana=$KATANA" >> $GITHUB_OUTPUT
        echo "tyvt=$TYVT" >> $GITHUB_OUTPUT
        echo "infrastructure=$INFRA" >> $GITHUB_OUTPUT
        echo "skip=$SKIP" >> $GITHUB_OUTPUT
        
        echo "üìä Changes: backend=$BACKEND orchestrator=$ORCHESTRATOR subfinder=$SUBFINDER dnsx=$DNSX httpx=$HTTPX katana=$KATANA tyvt=$TYVT infra=$INFRA skip=$SKIP"

  # ================================================================
  # Job 2: Build Containers
  # ================================================================
  build:
    name: Build Containers
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.skip == 'false'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to ECR
      id: ecr
      uses: aws-actions/amazon-ecr-login@v1
      
    - name: Build Backend
      if: needs.detect-changes.outputs.backend == 'true'
      run: |
        cd backend
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_BACKEND:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_BACKEND:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_BACKEND:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_BACKEND:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_BACKEND:latest
        echo "‚úÖ Backend built"
        
    - name: Build Orchestrator
      if: needs.detect-changes.outputs.orchestrator == 'true' || needs.detect-changes.outputs.backend == 'true'
      run: |
        # Build orchestrator from project root (Dockerfile expects cli/orchestrator/main.py path)
        docker build \
          --build-arg ECR_REGISTRY=${{ steps.ecr.outputs.registry }} \
          -f cli/orchestrator/Dockerfile \
          -t ${{ steps.ecr.outputs.registry }}/$ECR_ORCHESTRATOR:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_ORCHESTRATOR:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_ORCHESTRATOR:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_ORCHESTRATOR:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_ORCHESTRATOR:latest
        echo "‚úÖ Orchestrator built"
        
    - name: Build Subfinder
      if: needs.detect-changes.outputs.subfinder == 'true'
      run: |
        cd backend/containers/subfinder-go
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_SUBFINDER:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_SUBFINDER:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_SUBFINDER:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_SUBFINDER:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_SUBFINDER:latest
        echo "‚úÖ Subfinder built"
        
    - name: Build DNSx
      if: needs.detect-changes.outputs.dnsx == 'true'
      run: |
        cd backend/containers/dnsx-go
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_DNSX:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_DNSX:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_DNSX:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_DNSX:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_DNSX:latest
        echo "‚úÖ DNSx built"
        
    - name: Build HTTPx
      if: needs.detect-changes.outputs.httpx == 'true'
      run: |
        cd backend/containers/httpx-go
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_HTTPX:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_HTTPX:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_HTTPX:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_HTTPX:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_HTTPX:latest
        echo "‚úÖ HTTPx built"
        
    - name: Build Katana
      if: needs.detect-changes.outputs.katana == 'true'
      run: |
        cd backend/containers/katana-go
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_KATANA:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_KATANA:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_KATANA:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_KATANA:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_KATANA:latest
        echo "‚úÖ Katana built"
        
    - name: Build TYVT
      if: needs.detect-changes.outputs.tyvt == 'true'
      run: |
        cd backend/containers/tyvt-go
        docker build -t ${{ steps.ecr.outputs.registry }}/$ECR_TYVT:${{ github.sha }} .
        docker tag ${{ steps.ecr.outputs.registry }}/$ECR_TYVT:${{ github.sha }} ${{ steps.ecr.outputs.registry }}/$ECR_TYVT:latest
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_TYVT:${{ github.sha }}
        docker push ${{ steps.ecr.outputs.registry }}/$ECR_TYVT:latest
        echo "‚úÖ TYVT built"

  # ================================================================
  # Job 3: Deploy Infrastructure
  # ================================================================
  infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, build]
    if: always() && needs.detect-changes.outputs.infrastructure == 'true' && needs.build.result != 'failure'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false
        
    - name: Terraform Deploy
      # Secrets are read from AWS SSM Parameter Store (no GitHub secrets needed)
      # Only AWS credentials are required
      run: |
        cd infrastructure/terraform
        terraform init
        terraform apply -auto-approve

  # ================================================================
  # Job 4: Deploy ECS Service
  # ================================================================
  deploy:
    name: Deploy ECS
    runs-on: ubuntu-latest
    needs: [detect-changes, build, infrastructure]
    if: always() && needs.detect-changes.outputs.skip == 'false' && needs.build.result != 'failure'
    
    steps:
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Update ECS Service
      if: needs.detect-changes.outputs.backend == 'true'
      run: |
        REVISION=$(aws ecs describe-task-definition \
          --task-definition neobotnet-v2-dev-app-batch \
          --query 'taskDefinition.revision' --output text)
        
        # Force new deployment to pull latest image from ECR
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service neobotnet-v2-dev-service-batch \
          --task-definition neobotnet-v2-dev-app-batch:$REVISION \
          --force-new-deployment
        
        echo "‚è≥ Waiting for service stability..."
        aws ecs wait services-stable \
          --cluster $ECS_CLUSTER \
          --services neobotnet-v2-dev-service-batch
        
        echo "‚úÖ ECS service deployed"
        
    - name: Health Check
      run: |
        for i in {1..10}; do
          if curl -sf "https://aldous-api.neobotnet.com/health"; then
            echo "‚úÖ Health check passed"
            exit 0
          fi
          echo "Retry $i/10..."
          sleep 10
        done
        echo "‚ö†Ô∏è Health check timeout"

  # ================================================================
  # Job 5: Summary
  # ================================================================
  summary:
    name: Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, build, infrastructure, deploy]
    if: always()
    
    steps:
    - name: Deployment Summary
      run: |
        echo "üéØ LEAN DEPLOYMENT COMPLETE"
        echo ""
        echo "üìä What was built:"
        echo "  Backend: ${{ needs.detect-changes.outputs.backend }}"
        echo "  Subfinder: ${{ needs.detect-changes.outputs.subfinder }}"
        echo "  DNSx: ${{ needs.detect-changes.outputs.dnsx }}"
        echo "  HTTPx: ${{ needs.detect-changes.outputs.httpx }}"
        echo "  Katana: ${{ needs.detect-changes.outputs.katana }}"
        echo "  TYVT: ${{ needs.detect-changes.outputs.tyvt }}"
        echo ""
        echo "üîó Endpoints:"
        echo "  API: https://aldous-api.neobotnet.com"
        echo "  Health: https://aldous-api.neobotnet.com/health"

